import { describe, test, expect } from 'vitest';
import fc from 'fast-check';
import { getHeatmapIntensity, HeatmapIntensity, generateDayArray, DayData } from '../lib/heatmap';

/**
 * Heatmap Intensity Property-Based Tests
 * 
 * These tests verify the correctness properties of the heatmap intensity mapping
 * as specified in the design document.
 */

/**
 * **Feature: cekatan, Property 5: Heatmap Color Intensity Mapping**
 * **Validates: Requirements 2.3**
 * 
 * For any `cards_reviewed` count:
 * - 0 cards SHALL map to intensity 0 (empty)
 * - 1-5 cards SHALL map to intensity 1 (light)
 * - 6-15 cards SHALL map to intensity 2 (medium)
 * - 16+ cards SHALL map to intensity 3 (dark)
 */
describe('Property 5: Heatmap Color Intensity Mapping', () => {
  test('0 cards maps to intensity 0 (empty)', () => {
    const result = getHeatmapIntensity(0);
    expect(result).toBe(0);
  });

  test('Negative counts map to intensity 0 (empty)', () => {
    fc.assert(
      fc.property(fc.integer({ min: -1000, max: -1 }), (count) => {
        const result = getHeatmapIntensity(count);
        expect(result).toBe(0);
      }),
      { numRuns: 100 }
    );
  });

  test('1-5 cards maps to intensity 1 (light)', () => {
    fc.assert(
      fc.property(fc.integer({ min: 1, max: 5 }), (count) => {
        const result = getHeatmapIntensity(count);
        expect(result).toBe(1);
      }),
      { numRuns: 100 }
    );
  });

  test('6-15 cards maps to intensity 2 (medium)', () => {
    fc.assert(
      fc.property(fc.integer({ min: 6, max: 15 }), (count) => {
        const result = getHeatmapIntensity(count);
        expect(result).toBe(2);
      }),
      { numRuns: 100 }
    );
  });

  test('16+ cards maps to intensity 3 (dark)', () => {
    fc.assert(
      fc.property(fc.integer({ min: 16, max: 10000 }), (count) => {
        const result = getHeatmapIntensity(count);
        expect(result).toBe(3);
      }),
      { numRuns: 100 }
    );
  });

  test('Intensity is always a valid value (0, 1, 2, or 3)', () => {
    fc.assert(
      fc.property(fc.integer({ min: -100, max: 10000 }), (count) => {
        const result = getHeatmapIntensity(count);
        expect([0, 1, 2, 3]).toContain(result);
      }),
      { numRuns: 100 }
    );
  });

  test('Intensity is monotonically non-decreasing with count', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 0, max: 10000 }),
        fc.integer({ min: 0, max: 10000 }),
        (count1, count2) => {
          const [smaller, larger] = count1 <= count2 ? [count1, count2] : [count2, count1];
          const intensity1 = getHeatmapIntensity(smaller);
          const intensity2 = getHeatmapIntensity(larger);
          expect(intensity2).toBeGreaterThanOrEqual(intensity1);
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Boundary values are correctly mapped', () => {
    // Test exact boundary values
    expect(getHeatmapIntensity(0)).toBe(0);
    expect(getHeatmapIntensity(1)).toBe(1);
    expect(getHeatmapIntensity(5)).toBe(1);
    expect(getHeatmapIntensity(6)).toBe(2);
    expect(getHeatmapIntensity(15)).toBe(2);
    expect(getHeatmapIntensity(16)).toBe(3);
  });
});


/**
 * **Feature: v3.1-bugfix-ux-polish, Property 2: Heatmap Day Ordering**
 * **Validates: Requirements 1.4**
 * 
 * For any array of study days generated by the heatmap, the days SHALL be ordered
 * chronologically from oldest to newest, such that for all indices i < j,
 * days[i].date < days[j].date.
 */
describe('Property 2: Heatmap Day Ordering', () => {
  test('Days are ordered chronologically (oldest to newest)', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 1, max: 365 }), // dayCount between 1 and 365
        (dayCount) => {
          const logMap = new Map<string, number>();
          const result = generateDayArray(dayCount, logMap);
          
          // Verify array length matches requested day count
          expect(result.length).toBe(dayCount);
          
          // Verify chronological ordering: each date should be less than the next
          for (let i = 0; i < result.length - 1; i++) {
            expect(result[i].date < result[i + 1].date).toBe(true);
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Most recent day is always today', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 1, max: 365 }),
        (dayCount) => {
          const logMap = new Map<string, number>();
          const result = generateDayArray(dayCount, logMap);
          
          const today = new Date().toISOString().split('T')[0];
          const lastDay = result[result.length - 1];
          
          expect(lastDay.date).toBe(today);
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Day array correctly incorporates study log data', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 7, max: 60 }),
        fc.array(fc.integer({ min: 0, max: 100 }), { minLength: 1, maxLength: 10 }),
        (dayCount, counts) => {
          const logMap = new Map<string, number>();
          const today = new Date();
          
          // Add some study data for recent days
          counts.forEach((count, i) => {
            const date = new Date(today);
            date.setDate(today.getDate() - i);
            const dateStr = date.toISOString().split('T')[0];
            logMap.set(dateStr, count);
          });
          
          const result = generateDayArray(dayCount, logMap);
          
          // Verify that logged counts appear in the result
          counts.forEach((count, i) => {
            const date = new Date(today);
            date.setDate(today.getDate() - i);
            const dateStr = date.toISOString().split('T')[0];
            
            const dayData = result.find(d => d.date === dateStr);
            if (dayData) {
              expect(dayData.count).toBe(count);
            }
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Days without study data have count 0 and intensity 0', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 1, max: 100 }),
        (dayCount) => {
          const emptyLogMap = new Map<string, number>();
          const result = generateDayArray(dayCount, emptyLogMap);
          
          // All days should have count 0 and intensity 0
          result.forEach(day => {
            expect(day.count).toBe(0);
            expect(day.intensity).toBe(0);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  test('Intensity values are correctly computed from counts', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 1, max: 30 }),
        fc.array(
          fc.record({
            daysAgo: fc.integer({ min: 0, max: 29 }),
            count: fc.integer({ min: 0, max: 50 })
          }),
          { minLength: 1, maxLength: 10 }
        ),
        (dayCount, entries) => {
          const logMap = new Map<string, number>();
          const today = new Date();
          
          entries.forEach(({ daysAgo, count }) => {
            const date = new Date(today);
            date.setDate(today.getDate() - daysAgo);
            const dateStr = date.toISOString().split('T')[0];
            logMap.set(dateStr, count);
          });
          
          const result = generateDayArray(dayCount, logMap);
          
          // Verify intensity matches expected value for each day
          result.forEach(day => {
            const expectedIntensity = getHeatmapIntensity(day.count);
            expect(day.intensity).toBe(expectedIntensity);
          });
        }
      ),
      { numRuns: 100 }
    );
  });
});
